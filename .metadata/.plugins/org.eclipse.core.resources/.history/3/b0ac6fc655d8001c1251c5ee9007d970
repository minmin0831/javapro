package EJ01_Create_Destroy_Object;

import java.util.Date;

public class StaticFactory {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}
	
	// 생성자 대신 정적 팩토리 메서드를 고려하라.
	// 클래스는 생성자와 별도로 정적 팩토리 메서드를 제공할 수 있다. 그 클래스의 인스턴스를 반환하는 단순한 정적 메서드 말이다. 
	
	// static factory method 
	public static Boolean valueOf(boolean b) {
		return b ? Boolean.TRUE : Boolean.FALSE;
	}
	
	// 정적 팩토리 메서드가 생성자보다 좋은 장점 5 가지 
	
	// 1. 이름을 가질 수 있다. 생성자에 넘기는 매새변수와 생성자 자체만으로는 반환될 객체의 특성을 제대로 설명하지 못한다. 반면 정적 팩토리는 이름만 잘 지으면 반환될 객체의 특성을 쉽게 묘사할 수 있다. 
	// 비교: BigInteger(int, int, Random)과 BigInteger.probablePrime 중 어느 쪽이 값이 소수인 BigInteger를 반환한다는 의미를 더 잘 설명하는 것 같은지 생각해보라. 
	
	// 2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다. 이 덕분에 불변 클래스는 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용하는 식으로 불필요한 객체 생성을 피할 수 있다. 
	// 예시: Boolean.valueOf(bool) 메서드는 객체를 아예 생성하지 않는다. 
	// 반복되는 요청에 같은 객체를 반환하는 식으로 정적 팩토리 방식의 클래스는 언제 어느 인스턴스를 살아 있게 할지 철저히 통제할 수 있다. 이런 클래스를 인스턴스 통제 클래스라 한다. 
	
	// 3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다. 반환할 객체의 클래스를 자유롭게 선택할 수 있게 하는 '엄청난 유연성'을 선물한다.
	// 예시: java.util.Collections 에서 정적 팩토리 메서드를 통해 유틸리티 구현체를 제공하고 있다. (검색 필요) 
	
	// 4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다. 
	// 예시: 생성자 없이 팩토리 메서드만 제공하는 EnumSet의 경우, element가 65개 이상이면 JumboEnumSet을 65개 이하면 RegularEnumSet을 반환한다. 
	// 하지만 클라이언트는 이 존재를 모르고 팩토리가 건네주는 객체가 어느 클래스의 인스턴스인지도 알 수도 없고 알 필요도 없다. 
	
	// 5. 정적 팩토리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다. 
	// 예시: JDBC는 서비스 제공자 프레임워크로써 서비스 구현체를 제공한다. 이 구현체들을 클라이언트에 제공하는 역할을 프레임워크가 통제하여, 클라이언트를 구현체로부터 분리해준다. 
	
	// 서비스 제공자 프레임워크는 3개의 핵심 컴포넌트로 이루어져있다. (예시: JDBC)
	// 1. 구현체의 동작을 정의하는 '서비스 인터페이스' -> Connection
	// 2. 제공자가 구현체를 등록할 때 사용하는 '제공자 등록 API' -> DriverManager.registerDriver
	// 3. 클라이언트가 서비스의 인스턴스를 얻을 때 사용하는 '서비스 접근 API'가 그 주인공이다. -> DriverManager.getConnection
	// 클라이언트는 서비스 접근 API를 사용할 때 원하는 구현체의 조건을 명시할 수 있다. 조건을 명시하지 않으면, 기본 구현체를 반환하거나 지원하는 구현체들을 하나씩 돌아가며 반환한다. 
	// 이 서비스 접근 API가 바로 서비스 제공자 프레임워크의 근간이라고 한 '유연한 정적 팩토리'의 실체이다. 
	// 4. '서비스 제공자 인터페이스'는 종종 네번째 컴포넌트로 불리우며, 이 컴포넌트는 서비스 인터페이스의 인스턴스를 생성하는 팩토리 객체를 설명해준다. ->  Driver
	
	// 정적 팩토리 메서드의 단점 
	// 1. 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩토리 메서드만 제공하면 하위 클래스를 만들 수 없다. 앞서 이야기한 프레임워크의 유틸리티 구현 클래스들은 상속할 수 없다는 이야기다. 
	// 2. 정적 팩토리 메서드는 프로그래머가 찾기 어렵다. 때문에 API 문서를 잘 써놓고 메서드 이름도 널리 알려진 규약을 따라 짓는 식으로 문제를 완화해줘야 한다. 
	// 아래는 흔히 사용하는 명명 방식들이다. 
	
	// from: 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드 
	Date d = Date.from(instant); 
	
	
	
	
}
